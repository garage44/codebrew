---
description: "Linting workflow - hooks handle auto-formatting, manual linting only when needed"
globs:
  - "**/*.{ts,tsx,js,jsx,css}"
alwaysApply: true
priority: 1
---

# Linting Workflow

**Linting is handled automatically by hooks - agents should NOT manually lint after each change.**

## Automatic Linting

This project uses automated linting via hooks:

1. **After file edits**: `.cursor/hooks/format.sh` auto-formats files with oxlint/eslint/stylelint
2. **Before commits**: Lefthook runs `lint-staged` which auto-fixes staged files
3. **Commit messages**: Commitlint validates conventional commit format

**Agents should rely on these hooks** - no need to manually run linting after each change.

## Manual Linting Commands

Use these commands only when needed (e.g., fixing existing issues, checking before manual commits):

```bash
# TypeScript linting (syntax, style, types)
bun run lint:ts

# CSS linting
bun run lint:css

# Individual checks
bun run lint:ts-syntax   # oxlint
bun run lint:ts-style    # eslint
bun run lint:ts-types    # TypeScript type checking
```

**Auto-fixing:**
- oxlint/eslint/stylelint support `--fix` flags
- Lefthook's lint-staged automatically fixes issues before commit

## TypeScript Fix Strategy

**CRITICAL: Fix types at interface definitions, not at usage sites.**

When fixing TypeScript errors:

1. **Trace errors to source**: Find the interface/type definition causing the issue
2. **Fix at definition**: Update the interface/type to match actual usage patterns
3. **Use inference**: Let TypeScript infer types instead of explicit annotations when possible
4. **Avoid unnecessary conditionals**: Don't add `if (x !== undefined)` checks just to satisfy TypeScript
5. **Avoid type assertions**: Don't use `as Type` or `!` assertions - fix the underlying type instead

### Examples

**❌ Bad: Adding conditionals everywhere**
```tsx
// Interface says name?: string, but it's always present
interface User {
  name?: string
}

// Bad: Adding checks everywhere
if (user?.name) {
  console.log(user.name)
}
```

**✅ Good: Fix the interface**
```tsx
// Fix at the source - if name is always present, make it required
interface User {
  name: string
}

// Now no conditionals needed
console.log(user.name)
```

**❌ Bad: Type assertions**
```tsx
// Bad: Silencing errors with assertions
const value = data as ExpectedType
const result = maybeNull!.property
```

**✅ Good: Fix the type definition**
```tsx
// Fix the function signature or interface
function processData(data: ExpectedType): Result {
  // Type is correct, no assertion needed
}
```

**❌ Bad: Explicit types when inference works**
```tsx
// Bad: Unnecessary explicit type
const items: string[] = ['a', 'b', 'c']
const user: User = { name: 'John' }
```

**✅ Good: Use inference**
```tsx
// Good: Let TypeScript infer
const items = ['a', 'b', 'c']  // inferred as string[]
const user = { name: 'John' }  // inferred from usage
```

### Workflow for TypeScript Errors

1. Read the error message carefully - understand what type mismatch exists
2. Identify the type causing the issue - find where it's defined
3. Trace to interface/type definition - follow imports to find the source
4. Determine root cause - is the type definition wrong or the usage?
5. Fix at source - update interface/type definition when possible
6. Only add guards if truly needed - if value can legitimately be undefined/null in that context
7. Use inference - remove explicit types when TypeScript can infer correctly

## Linting Rules Reference

This project has **200+ strict stylistic rules** covering:
- No semicolons (`@stylistic/semi: never`)
- Single quotes only (`@stylistic/quotes: single`)
- 4-space indentation with complex rules
- JSX formatting (props, spacing, self-closing)
- Object/array property sorting (perfectionist plugin)
- Specific spacing rules for every construct

See `eslint.config.js` for complete rule details.

## Commands for Linting

- `/fix-lint` - Fix linting issues in changed files only (optimized, low token usage)
- `/lint-workspace` - Lint entire workspace or specific package (with TypeScript inference strategy)
